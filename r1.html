<!doctype html><html><head>

    <!-- Meta data stuff -->
    <meta charset="utf-8" />
    <title>experiment 6</title>
    <script src="utils.js"></script>
    <script src="display.js"></script>
    <script src="entities.js"></script>
    <script src="grid.js"></script>

</head><body>
<div>
    <button onclick="start()">start</button>
    <button onclick="stop()">stop</button>
</div>
<script>

////////////////////////////////////////////////////////////////////////////////
//
//  NOTES:
/*

    -   I want entities to carry a genome of sorts so we can do the actual
        mutation and procreation.

        >   Should be easily done if I generate genomes in the entity creation.
            The real question is, how do I represent the genome?
            Do I use a large string of letters similar to DNA or do I just make
            an array with numbers or enumerables?

    -   I want the entities to interact with one another so that we can have
        a means to compare/contest the genomes between entities.

        >   I've got collision detection of sorts now. I should look into
            making colliding entities assess oneanother and then either do
            something or not. Something could be attack/kill and or (attempt to)
            breed?

    -   Eventually I want to have all the metrics that are active, to be
        represented in the genome. (I don't yet know how to determine which part
        of the genome is changable.)

    -   I'd like to turn on/off drawing the background (makes for interesting
        views of the paths entities took and what territory they keep)

    -   I'd also like to be able to see how many entities are still active
        (I use a degenerate method now using the console: entities.length)

*/

///////////
// Declarations

    var WIDTH = 800;
    var HEIGHT = 600;
    var NUM_ENTITIES = 100;

    var display;
    var entities;
    var grid;
    var animating;

    function createDisplay() {

        display = getDisplay(WIDTH, HEIGHT);

    }

    function createEntities(amount) {

        entities = getEntities(amount);

    }

    function createGrid() {

        grid = Grid.create(WIDTH, HEIGHT);

    }

    //#NOTE: Am I happy with this here? It's just the initial generation right?
    // so it shouldn't matter if this is here?
    function positionEntityRandomly(entity) {

        entity.x = generateRandomNumber(0, WIDTH);
        entity.y = generateRandomNumber(0, HEIGHT);

    }

    function positionEntities(p_entities) {

        p_entities.map(positionEntityRandomly);

    }

    function load() {

        createDisplay();
        createEntities(NUM_ENTITIES);
        createGrid();
        positionEntities(entities);

    }

// ----

    function getRandomDirection() {

        var heading;
        var direction;

        heading = Math.random() * (Math.PI * 2);

        direction = {x: Math.cos(heading), y: Math.sin(heading)};

        return direction;

    }

    //#REFACTOR: the randomised movement to use the genome!
    function moveEntity(entity) {

        var direction;

        direction = getRandomDirection();

        entity.x += entity.speed * direction.x * 0.02;
        entity.y += entity.speed * direction.y * 0.02;

    }

    function getLivingEntities(p_entities) {

        var entities;

        function addLivingEntity(entity) {

            if (entity.status !== 0) {

                entities.push(entity);

            }

        }

        entities = [];

        p_entities.map(addLivingEntity);

        return entities;

    }

    function moveEntities(p_entities) {

        p_entities.map(moveEntity);

    }

    //#REFACTOR: See drawEntity
    function addEntitiesToGrid(p_entities, p_grid) {

        var entity;
        var x;
        var w;
        var y;
        var h;

        var max = Math.max;
        var min = Math.min;
        var ceil = Math.ceil;
        var width = WIDTH;
        var height = HEIGHT;
        var half_size;

        var i = 0;
        var n = p_entities.length;

        for ( i; i < n; i += 1 ) {

            entity = p_entities[i];

            half_size = (entity.size / 2);
            x = max(0, ceil(entity.x - half_size));
            w = min(width, ceil(x + entity.size));

            for (x; x < w; x += 1) {

                y = max(0, ceil(entity.y - half_size));
                h = min(height, ceil(y + entity.size));

                for (y; y < h; y += 1) {

                    Grid.addOccupant(p_grid, x, y, i);

                }

            }

        }

    }

    function kill(p_entity) {

        p_entity.status = 0;

    }

    function sortEntitiesOnFitness(p_left_entity, p_right_entity) {

        var str;
        var spd;
        var size;

        var left = -1;
        var right = -1;

        if (p_left_entity.status !== 0) {

            str = p_left_entity.strength;
            spd = p_left_entity.speed;
            size = p_left_entity.size;

            // For now average the lot...
            left = (str + spd + size) / 3;

        }

        if (p_right_entity.status !== 0) {

            str = p_right_entity.strength;
            spd = p_right_entity.speed;
            size = p_right_entity.size;

            right = (str + spd + size) / 3;

        }

        return left - right;

    }

    //#REFACTOR: too many indents. we can clean this up I'm sure!
    function resolveTouchingEntities(p_entities, p_grid) {

        var row;
        var col;
        var i;
        var n;
        var w = WIDTH;
        var h = HEIGHT;
        var entities;

        row = 0;

        for (row; row < w; row += 1) {

            col = 0;

            for (col; col < h; col += 1) {

                if ( Grid.isOccupied(grid, row, col)) {

                    occupants = Grid.getOccupants(grid, row, col);

                    occupant_ids = Object.keys(occupants);

                    if (occupant_ids.length > 1) {

                        entities = [];

                        i = 0;
                        n = occupant_ids.length;

                        for (i; i < n; i += 1) {

                            id = occupant_ids[i];
                            entity = p_entities[id];
                            entities.push(entity);

                        }

                        // Sort on strength Ascending.
                        entities.sort(sortEntitiesOnFitness);

                        // Kill all but the last and strongest entity occupying
                        // this grid location.
                        i = 0;
                        n = entities.length - 1;

                        for (i; i < n; i += 1) {

                            entity = entities[i];

                            kill(entity);

                        }

                    }

                }

            }

        }

    }

    function isOutOfBounds(entity) {

        var left = (entity.x < 0);
        var right = (entity.x > WIDTH);
        var top = (entity.y < 0);
        var bottom = (entity.y > HEIGHT);

        return (left || right || top || bottom);

    }

    function checkForDeath(entity) {

        if (isOutOfBounds(entity)) {

            kill(entity);

        }

    }

    function updateEntities(p_entities) {

        resolveTouchingEntities(p_entities, grid);

        p_entities.map(checkForDeath);

    }

// ----

    function updateValues() {

        entities = getLivingEntities(entities);

        moveEntities(entities);

        Grid.reset(grid);

        addEntitiesToGrid(entities, grid);

        updateEntities(entities);

    }

// ----

    function drawBackground() {

        display.fill("rgba(15, 15, 15, 1)");

    }

    //#REFACTOR: How do I merge this with the logic in 'addEntitiesToGrid'
    // I'm doing unit occupation calculations in two places. Perhaps move it
    // to entity class itself? Resolution is fixed due to units anyway.
    function drawEntity(entity) {

        var half_size = (entity.size / 2);

        display.drawRect(
            entity.x - half_size,
            entity.y - half_size,
            entity.size,
            entity.size,
            entity.color
        )

    }

    function drawEntities(p_entities) {

        p_entities.map(drawEntity);

    }

    function updateDisplay() {

        drawBackground();

        drawEntities(entities);

    }

    function tic() {

        updateValues();

        updateDisplay();

        if (animating === true) {

            window.requestAnimationFrame(tic);

        }

    }

    function start() {

        if (animating === true) {

            return;

        }

        animating = true;

        tic();

    }

    function stop() {

        animating = false;

    }

///////////
// Execution

    load();

</script></body></html>
